<style>
    #displayWindow{
        border:1px solid #999;
    }
</style>

<script type="text/javascript">
    class Game {
        constructor() {
            this.windowScale = 5;
            this.gameWidth = 800;
            this.gameHeight = 600;
            this.speed = 25;
            this.gameWindow = "";
            this.continuous = true;

            this.cells = [];
            this.color = {
                r: this.randomColorChannel(),
                g: this.randomColorChannel(),
                b: this.randomColorChannel(),
            };
            this.iteration = 0;
            this.colorIteration;
            this.processing = false;
        }

        randomColorChannel() {
            return Math.floor(Math.random() * 254);
        }

        initialize() {
            this.gameWindow = document.getElementById("displayWindow");
            this.gameWindow.setAttribute("width", this.gameWidth);
            this.gameWindow.setAttribute("height", this.gameHeight);
            this.gameColumns = Math.round(this.gameWidth / this.windowScale);
            this.gameRows = Math.round(this.gameHeight / this.windowScale);

            this.colorFn = this.colorCellsCycle; // or this.colorCellsRandomly

            // set initial cell states
            const emptyColumn = Array(this.gameRows).fill(false);
            this.cells = Array(this.gameColumns)
                .fill(false)
                .map(() => [...emptyColumn]);
        }

        seedRandomly() {
            this.cells = this.cells.map(outer => outer.map(() => Math.random() < 0.5));
            this.redraw();
        }

        activateCellViaMouse(evt) {
            var canvasPosition = this.gameWindow.getBoundingClientRect();
            var mouseX = evt.clientX - canvasPosition.left;
            var mouseY = evt.clientY - canvasPosition.top;

            var xPos = (mouseX - (mouseX % this.windowScale))/this.windowScale;
            var yPos = (mouseY - (mouseY % this.windowScale))/this.windowScale;
            if ((evt.type === "click" && evt.button === 0) || (evt.type === "mousemove" && evt.buttons > 0)) {
                this.toggleCell(xPos, yPos);
            }
        }

        loop() {
            if(!this.processing) {
                this.processing = true;
                this.iteration++;
                this.processCells();
                this.redraw();
                this.processing = false;

                if(this.continuous){
                    window.setTimeout(function(obj){obj.loop()},this.speed, this);
                }
            }
        }

        step(start) {
            this.continuous = start;
            this.loop();
        }

        redraw() {
            var currentContext = this.gameWindow.getContext("2d");
            // Clear canvas
            currentContext.clearRect(0, 0, this.gameWindow.width, this.gameWindow.height);

            // Redraw all cells
            this.cells.forEach((column, x) => column.forEach((cell, y) => this.drawCell(x, y, cell)));
        }

        toggleCell(xPos,yPos) {
            this.cells[xPos][yPos] = !this.cells[xPos][yPos];
            this.drawCell(xPos, yPos, this.cells[xPos][yPos]);
        }

        drawCell(xPos, yPos, alive) {
            var currentContext = this.gameWindow.getContext("2d");
            var actualX = xPos * this.windowScale;
            var actualY = yPos * this.windowScale;

            currentContext.fillStyle = alive ? this.colorFn() : "rgb(255, 255, 255)";
            currentContext.fillRect(actualX, actualY, this.windowScale, this.windowScale);
        }

        processCells() {
            this.cells = this.cells.map((currentColumn, x) => currentColumn.map((cell, y) => {
                const liveNeighbors = [-1, 0, 1].reduce((countX, offsetX) => {
                    return countX + [-1, 0, 1].reduce((countY, offsetY) => {
                        var neighborX = x + offsetX;
                        var neighborY = y + offsetY;
                        if(!(neighborX === x && neighborY === y) && this.cells[neighborX] && this.cells[neighborX][neighborY]) {
                            return countY + 1;
                        }
                        return countY;
                    }, 0);
                }, 0);
                return this.applyRules(cell, liveNeighbors);
            }));
        }

        applyRules(cell, neighborCount) {
            return (!cell && neighborCount === 3) ||
                (cell && (neighborCount === 2 || neighborCount === 3));
        }

        colorCellsRandomly() {
            const [r, g, b] = [this.randomColorChannel(), this.randomColorChannel(), this.randomColorChannel()];
            return `rgb(${r}, ${g}, ${b})`;
        }

        colorCellsCycle() {
            if(this.colorIteration !== this.iteration){
                this.colorIteration = this.iteration;
                this.color = Object.keys(this.color).reduce((colorObject, c) => {
                    const color = this.color[c];
                    const newColor = color + (Math.floor(Math.random() * 3) - 1) * Math.floor(Math.random() * 10);
                    colorObject[c] = Math.min(Math.max(newColor, 1), 254);
                    return colorObject;
                }, {});
            }
            return `rgb(${this.color.r}, ${this.color.g}, ${this.color.b})`;
        }
    }

    const gameObj = new Game;

    window.onload = () => {
        gameObj.initialize();
        gameObj.gameWindow.addEventListener("click", function(evt){gameObj.activateCellViaMouse(evt)}, false);
        gameObj.gameWindow.addEventListener("mousemove", function(evt){gameObj.activateCellViaMouse(evt)}, false);
    };
</script>

<html>
<body>
    <div>
        <input type="button" value="Start" onClick="gameObj.step(true)">
        <input type="button" value="Stop" onClick="gameObj.continuous = false">
        <input type="button" value="Step" onClick="gameObj.step()">
        <input type="button" value="seed randomly" onClick="gameObj.seedRandomly()">
    </div>

    <canvas id="displayWindow"></canvas>
</body>
</html>
