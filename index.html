<style>
  #displayWindow {
    border: 1px solid #999;
  }
</style>

<script type="text/javascript">
  class Game {
    constructor() {
      this.settings = {
        gameHeight: 600,
        gameWidth: 800,
        interval: 25,
        windowScale: 5
      };

      this.gameWindow = null;
      this.context = null;
      this.continuous = true;
      this.cells = [];
      this.color = [
        this.randomColorChannel(),
        this.randomColorChannel(),
        this.randomColorChannel()
      ];
      this.iteration = 0;
      this.colorIteration;
      this.processing = false;
    }

    randomColorChannel() {
      return Math.floor(Math.random() * 254);
    }

    initialize() {
      const { gameHeight, gameWidth, windowScale } = this.settings;

      this.gameWindow = document.getElementById("displayWindow");
      this.gameWindow.setAttribute("width", gameWidth);
      this.gameWindow.setAttribute("height", gameHeight);

      this.context = this.gameWindow.getContext("2d");

      this.colorFn = this.colorCellsCycle; // or this.colorCellsRandomly

      this.sizeCells();
    }

    seedRandomly() {
      this.cells = this.cells.map(outer =>
        outer.map(() => Math.random() < 0.5)
      );
      this.redraw();
    }

    activateCellViaMouse(evt) {
      const { windowScale } = this.settings;

      let canvasPosition = this.gameWindow.getBoundingClientRect();
      let mouseX = evt.clientX - canvasPosition.left;
      let mouseY = evt.clientY - canvasPosition.top;

      let xPos = (mouseX - (mouseX % windowScale)) / windowScale;
      let yPos = (mouseY - (mouseY % windowScale)) / windowScale;
      if (
        (evt.type === "click" && evt.button === 0) ||
        (evt.type === "mousemove" && evt.buttons > 0)
      ) {
        this.toggleCell(xPos, yPos);
      }
    }

    loop() {
      if (!this.processing) {
        this.processing = true;
        this.iteration++;
        this.processCells();
        this.redraw();
        this.processing = false;

        if (this.continuous) {
          window.setTimeout(obj => obj.loop(), this.settings.interval, this);
        }
      }
    }

    step(start) {
      this.continuous = start;
      this.loop();
    }

    redraw() {
      this.cells.forEach((column, x) =>
        column.forEach((cell, y) => this.drawCell(x, y, cell))
      );
    }

    toggleCell(xPos, yPos) {
      this.cells[xPos][yPos] = !this.cells[xPos][yPos];
      this.drawCell(xPos, yPos, this.cells[xPos][yPos]);
    }

    drawCell(xPos, yPos, alive) {
      const { windowScale } = this.settings;
      let actualX = xPos * windowScale;
      let actualY = yPos * windowScale;

      this.context.fillStyle = alive ? this.colorFn() : "rgb(255, 255, 255)";
      this.context.fillRect(actualX, actualY, windowScale, windowScale);
    }

    processCells() {
      this.cells = this.cells.map((currentColumn, x) =>
        currentColumn.map((cell, y) => {
          const liveNeighbors = [-1, 0, 1].reduce((countX, offsetX) => {
            return (
              countX +
              [-1, 0, 1].reduce((countY, offsetY) => {
                let neighborX = x + offsetX;
                let neighborY = y + offsetY;
                if (
                  !(neighborX === x && neighborY === y) &&
                  this.cells[neighborX] &&
                  this.cells[neighborX][neighborY]
                ) {
                  return countY + 1;
                }
                return countY;
              }, 0)
            );
          }, 0);
          return this.applyRules(cell, liveNeighbors);
        })
      );
    }

    applyRules(cell, neighborCount) {
      return (
        (!cell && neighborCount === 3) ||
        (cell && (neighborCount === 2 || neighborCount === 3))
      );
    }

    colorCellsRandomly() {
      return `rgb(
                ${this.randomColorChannel()},
                ${this.randomColorChannel()},
                ${this.randomColorChannel()}
            )`;
    }

    colorCellsCycle() {
      if (this.colorIteration !== this.iteration) {
        this.colorIteration = this.iteration;
        this.color = this.color.map(c => {
          const newColor =
            c +
            (Math.floor(Math.random() * 3) - 1) *
              Math.floor(Math.random() * 10);
          return Math.min(Math.max(newColor, 1), 254);
        });
      }
      return `rgb(${this.color.join(",")})`;
    }

    speed(factor) {
      this.settings.interval /= factor;
    }

    scale(direction) {
      if (this.settings.windowScale + direction > 0) {
        this.settings.windowScale += direction;
        this.sizeCells();
      }
    }

    sizeCells() {
      const { gameHeight, gameWidth, windowScale } = this.settings;

      const gameColumns = Math.round(gameWidth / windowScale);
      const gameRows = Math.round(gameHeight / windowScale);
      const emptyColumn = Array(gameRows).fill(false);

      if (!this.cells.length) {
        // set initial cell states
        this.cells = Array(gameColumns)
          .fill(false)
          .map(() => [...emptyColumn]);
      } else {
        const columnDifference = gameColumns - this.cells.length;
        if (columnDifference < 0) {
          this.cells = this.cells.slice(0, columnDifference);
        } else if (columnDifference > 0) {
          this.cells = this.cells.concat(
            Array(columnDifference)
              .fill(false)
              .map(() => [...emptyColumn])
          );
        }

        const rowDifference = gameRows - this.cells[0].length;
        if (rowDifference < 0) {
          this.cells = this.cells.map(c => {
            return c.slice(0, rowDifference);
          });
        } else if (rowDifference > 0) {
          this.cells = this.cells.map(c => {
            return c.concat(Array(rowDifference).fill(false));
          });
        }
      }
    }
  }

  const gameObj = new Game();

  window.onload = () => {
    gameObj.initialize();
    gameObj.gameWindow.addEventListener("click", evt =>
      gameObj.activateCellViaMouse(evt)
    );
    gameObj.gameWindow.addEventListener("mousemove", evt =>
      gameObj.activateCellViaMouse(evt)
    );
  };
</script>

<html>
  <body>
    <div>
      <input type="button" value="Start" onclick="gameObj.step(true)" />
      <input type="button" value="Stop" onclick="gameObj.continuous = false" />
      <input type="button" value="Step" onclick="gameObj.step()" />
      <input
        type="button"
        value="Random Seed"
        onClick="gameObj.seedRandomly()"
      />
      <input type="button" value="Slower" onclick="gameObj.speed(0.5)" />
      <input type="button" value="Faster" onclick="gameObj.speed(2)" />
      <input type="button" value="Smaller" onclick="gameObj.scale(-1)" />
      <input type="button" value="Bigger" onclick="gameObj.scale(1)" />
    </div>

    <canvas id="displayWindow"></canvas>
  </body>
</html>
